<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Root Word Game</title>
    <style>
        /* --- VISUAL STYLING START (Mint Green Theme) --- */
        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background-color: #d1e7dd; /* SOFT MINT GREEN BACKGROUND */
            text-align: center;
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* Aligned to the top */
            min-height: 100vh; /* Ensure it takes full height */
            max-width: 600px;
            margin: 0 auto;
        }
        #game-area {
            width: 100%;
            margin-top: 20px; /* Added margin to prevent cutoff */
        }
        h1 { 
            color: #2c3e50;
            font-size: 2.8rem; 
            margin-bottom: 5px; 
            margin-top: 0; 
        }
        .question-text { 
            font-size: 1.3rem; 
            color: #7f8c8d;
            margin-bottom: 30px; 
        }
        
        /* New UI for Meaning/POS (Restored) */
        .info-box {
            background-color: #ecf0f1;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 0.95rem;
            color: #34495e;
            text-align: center;
        }
        .info-box span {
            font-weight: bold;
            color: #2c3e50;
        }
        .info-box p {
            margin: 5px 0;
        }
        .main-word-clickable {
            cursor: pointer;
            text-decoration: underline;
            text-decoration-thickness: 2px;
            text-decoration-color: #3498db;
        }

        /* Progress Bar */
        .progress-container {
            width: 100%;
            background-color: #bdc3c7;
            border-radius: 15px;
            margin-bottom: 20px;
            height: 12px;
        }
        .progress-bar {
            height: 100%;
            background-color: #3498db; /* Clear Blue */
            border-radius: 15px;
            width: 0%;
            transition: width 0.4s ease-out;
        }
        .level-indicator {
            font-size: 1rem;
            color: #2c3e50; /* Darker for better visibility */
            margin-bottom: 10px;
            text-align: left;
        }

        .btn-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        button {
            background-color: white;
            border: 2px solid #3498db; /* Blue Border */
            color: #2c3e50;
            padding: 16px;
            font-size: 1.3rem;
            border-radius: 25px; /* FULLY ROUNDED BUTTONS (Pill Shape) */
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.15); /* Stronger Shadow */
            
            /* HALO FIXES */
            outline: none !important; 
            -webkit-appearance: none; 
        }
        
        button:focus { 
            outline: none !important; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
        }

        button:hover { 
            background-color: #f5f5f5; 
            border-color: #2c3e50; /* Darker border on hover */
        }
        
        button:active { 
            transform: translateY(1px); 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
            background-color: #ecf0f1; 
        }
        
        /* Feedback Styles */
        .correct { 
            background-color: #d4f8e5 !important; 
            border-color: #2ecc71 !important; /* Bright Success Green */
            color: #2ecc71 !important; 
        }
        .wrong { 
            background-color: #fbecec !important; 
            border-color: #e74c3c !important; /* Clear Error Red */
            color: #e74c3c !important; 
            animation: shake 0.5s;
        }

        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-4px); }
            50% { transform: translateX(4px); }
            75% { transform: translateX(-4px); }
            100% { transform: translateX(0); }
        }

        .jp-sub {
            display: block;
            font-size: 0.8rem;
            font-weight: normal;
            color: #95a5a6;
            margin-top: 4px;
        }

        .reset-link {
            margin-top: 30px;
            color: #95a5a6;
            text-decoration: underline;
            font-size: 0.9rem;
            cursor: pointer;
            transition: color 0.2s;
        }
        .reset-link:hover {
            color: #2c3e50;
        }

        /* Report Card Styles */
        .report-card {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        .score-header {
            font-size: 1.8rem;
            color: #2c3e50;
            margin-bottom: 20px;
            font-weight: bold;
        }
        .score-breakdown {
            text-align: left;
            margin-bottom: 25px;
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 10px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-size: 1.1rem;
            color: #2c3e50;
            border-bottom: 1px solid #dcdcdc;
            padding-bottom: 5px;
        }
        .total-score {
            font-size: 3rem;
            color: #2ecc71;
            font-weight: bold;
            margin-top: 15px;
        }

        /* Explanation Styling */
        .explanation-box {
            background-color: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: left;
            font-size: 0.95rem;
            color: #34495e;
            line-height: 1.4;
        }
        .explanation-box h3 {
            color: #2c3e50;
            margin-top: 0;
            border-bottom: 2px solid #bdc3c7;
            padding-bottom: 5px;
            font-size: 1.2rem;
        }
        .explanation-box ul {
            padding-left: 20px;
        }
        .japanese-text {
            font-size: 0.9rem;
            color: #7f8c8d;
            border-top: 1px dashed #bdc3c7;
            padding-top: 10px;
            margin-top: 10px;
        }
        /* --- VISUAL STYLING END --- */
    </style>
</head>
<body>

    <div id="game-area">
        </div>

<script>
    // --- GLOBAL CONSTANTS ---
    const SECTION_SIZE = 10;
    
    // --- THE DATA STRUCTURE ---
    const levels = [
        // *** SECTION 1: CORE VOCABULARY ***
        { display: "Creative", root: "Create", decoys: ["Creation", "Crate"], pos: "Verb", derivativePos: "Adjective", jpMeaning: "å‰µé€ çš„ãª (SÅzÅ-teki na)", jpPos: "å½¢å®¹è©" },
        { display: "Excited", root: "Excite", decoys: ["Exci", "Cited"], pos: "Verb", derivativePos: "Adjective", jpMeaning: "ã‚ãã‚ãã—ãŸ (Wakuwaku shita)", jpPos: "å½¢å®¹è©" },
        { display: "Thirsty", root: "Thirst", decoys: ["Thirs", "Hersty"], pos: "Noun", derivativePos: "Adjective", jpMeaning: "å–‰ãŒæ¸‡ã„ãŸ (Nodo ga kawaita)", jpPos: "å½¢å®¹è©" },
        { display: "Bored", root: "Bore", decoys: ["Bo", "Ord"], pos: "Verb", derivativePos: "Adjective", jpMeaning: "é€€å±ˆã—ãŸ (Taikutsu shita)", jpPos: "å½¢å®¹è©" },
        { display: "Confused", root: "Confuse", decoys: ["Confu", "Fused"], pos: "Verb", derivativePos: "Adjective", jpMeaning: "æ··ä¹±ã—ãŸ (Konran shita)", jpPos: "å½¢å®¹è©" },
        { display: "Scared", root: "Scare", decoys: ["Sca", "Aird"], pos: "Verb", derivativePos: "Adjective", jpMeaning: "æ€–ãŒã£ãŸ (Kowagatta)", jpPos: "å½¢å®¹è©" },
        { display: "Nervous", root: "Nerve", decoys: ["Nerva", "Ous"], pos: "Noun", derivativePos: "Adjective", jpMeaning: "ç·Šå¼µã—ãŸ (KinchÅ shita)", jpPos: "å½¢å®¹è©" },
        { display: "Careful", root: "Care", decoys: ["Cay", "Are"], pos: "Verb", derivativePos: "Adjective", jpMeaning: "æ³¨æ„æ·±ã„ (ChÅ«i-bukai)", jpPos: "å½¢å®¹è©" },
        { display: "Friendly", root: "Friend", decoys: ["Frie", "End"], pos: "Noun", derivativePos: "Adjective", jpMeaning: "è¦ªã—ã¿ã‚„ã™ã„ (Shitamiyasui)", jpPos: "å½¢å®¹è©" },
        { display: "Beautiful", root: "Beauty", decoys: ["Beaut", "Be"], pos: "Noun", derivativePos: "Adjective", jpMeaning: "ç¾ã—ã„ (Utsukushii)", jpPos: "å½¢å®¹è©" },
        
        // *** SECTION 2: COMMON AFFIXES ***
        { display: "Dishonesty", root: "Honest", decoys: ["Dishon", "Esty"], pos: "Adjective", derivativePos: "Noun", jpMeaning: "ä¸æ­£ç›´ (FushÅjiki)", jpPos: "åè©" },
        { display: "Improvement", root: "Improve", decoys: ["Impro", "Ment"], pos: "Verb", derivativePos: "Noun", jpMeaning: "æ”¹å–„ (Kaizen)", jpPos: "åè©" },
        { display: "Invisibility", root: "Visible", decoys: ["Invisib", "Lity"], pos: "Adjective", derivativePos: "Noun", jpMeaning: "ä¸å¯è¦–æ€§ (Fukashisei)", jpPos: "åè©" },
        { display: "Decision", root: "Decide", decoys: ["Decis", "Cision"], pos: "Verb", derivativePos: "Noun", jpMeaning: "æ±ºå®š (Kettei)", jpPos: "åè©" },
        { display: "Happiness", root: "Happy", decoys: ["Happ", "Iness"], pos: "Adjective", derivativePos: "Noun", jpMeaning: "å¹¸ç¦ (KÅfuku)", jpPos: "åè©" },
        { display: "Disagreement", root: "Agree", decoys: ["Disagreem", "Dis"], pos: "Verb", derivativePos: "Noun", jpMeaning: "æ„è¦‹ã®ä¸ä¸€è‡´ (Iken no fuitchi)", jpPos: "åè©" },
        { display: "Creator", root: "Create", decoys: ["Creat", "Or"], pos: "Verb", derivativePos: "Noun", jpMeaning: "å‰µé€ ä¸» (SÅzÅshu)", jpPos: "åè©" },
        { display: "Complicated", root: "Complicate", decoys: ["Compli", "Cated"], pos: "Verb", derivativePos: "Adjective", jpMeaning: "è¤‡é›‘ãª (Fukuzatsu na)", jpPos: "å½¢å®¹è©" },
        { display: "Closed", root: "Close", decoys: ["Clo", "Osed"], pos: "Verb", derivativePos: "Adjective", jpMeaning: "é–‰é–ã•ã‚ŒãŸ (Heisa sareta)", jpPos: "å½¢å®¹è©" },
        { display: "Dangerous", root: "Danger", decoys: ["Dange", "Gerous"], pos: "Noun", derivativePos: "Adjective", jpMeaning: "å±é™ºãª (Kiken na)", jpPos: "å½¢å®¹è©" },

        // *** SECTION 3: COMPLEX VOCABULARY ***
        { display: "Healthy", root: "Health", decoys: ["Hell", "Elthy"], pos: "Noun", derivativePos: "Adjective", jpMeaning: "å¥åº·çš„ãª (KenkÅ-teki na)", jpPos: "å½¢å®¹è©" },
        { display: "Disgusting", root: "Disgust", decoys: ["Dis", "Gust"], pos: "Verb", derivativePos: "Adjective", jpMeaning: "ã†ã‚“ã–ã‚Šã™ã‚‹ã‚ˆã†ãª (Unzari suru yÅ na)", jpPos: "å½¢å®¹è©" },
        { display: "Interesting", root: "Interest", decoys: ["Inter", "Esting"], pos: "Verb", derivativePos: "Adjective", jpMeaning: "èˆˆå‘³æ·±ã„ (KyÅmi-bukai)", jpPos: "å½¢å®¹è©" },
        { display: "Boring", root: "Bore", decoys: ["Bo", "Ring"], pos: "Verb", derivativePos: "Adjective", jpMeaning: "ã¤ã¾ã‚‰ãªã„ (Tsumaranai)", jpPos: "å½¢å®¹è©" },
        { display: "Funny", root: "Fun", decoys: ["Fu", "Unny"], pos: "Noun", derivativePos: "Adjective", jpMeaning: "ãŠã‹ã—ã„ (Okashii)", jpPos: "å½¢å®¹è©" },
        { display: "Annoying", root: "Annoy", decoys: ["Anno", "Oying"], pos: "Verb", derivativePos: "Adjective", jpMeaning: "è¿·æƒ‘ãª (Meiwaku na)", jpPos: "å½¢å®¹è©" },
        { display: "Messy", root: "Mess", decoys: ["Me", "Essy"], pos: "Noun", derivativePos: "Adjective", jpMeaning: "æ•£ã‚‰ã‹ã£ãŸ (Chirakatta)", jpPos: "å½¢å®¹è©" },
        { display: "Expensive", root: "Expense", decoys: ["Expe", "Sive"], pos: "Noun", derivativePos: "Adjective", jpMeaning: "é«˜ä¾¡ãª (KÅka na)", jpPos: "å½¢å®¹è©" },
        { display: "Valuable", root: "Value", decoys: ["Val", "Able"], pos: "Verb", derivativePos: "Adjective", jpMeaning: "è²´é‡ãª (KichÅ na)", jpPos: "å½¢å®¹è©" },
        { display: "Worthless", root: "Worth", decoys: ["Wore", "Less"], pos: "Noun", derivativePos: "Adjective", jpMeaning: "ä¾¡å€¤ã®ãªã„ (Kachi no nai)", jpPos: "å½¢å®¹è©" },

        // *** SECTION 4: OPPOSITES/NEGATIVES (9 WORDS) ***
        { display: "Famous", root: "Fame", decoys: ["Fama", "Mous"], pos: "Noun", derivativePos: "Adjective", jpMeaning: "æœ‰åãª (YÅ«mei na)", jpPos: "å½¢å®¹è©" },
        { display: "Unknown", root: "Know", decoys: ["No", "Own"], pos: "Verb", derivativePos: "Adjective", jpMeaning: "æœªçŸ¥ã® (Michi no)", jpPos: "å½¢å®¹è©" },
        { display: "Different", root: "Differ", decoys: ["Diff", "Erent"], pos: "Verb", derivativePos: "Adjective", jpMeaning: "ç•°ãªã‚‹ (Kotonaru)", jpPos: "å½¢å®¹è©" },
        { display: "Opposite", root: "Oppose", decoys: ["Oppo", "Site"], pos: "Verb", derivativePos: "Adjective", jpMeaning: "åå¯¾ã® (Hantai no)", jpPos: "å½¢å®¹è©" },
        { display: "Unnecessary", root: "Necessary", decoys: ["Uness", "Sary"], pos: "Adjective", derivativePos: "Adjective", jpMeaning: "ä¸å¿…è¦ãª (FuhitsuyÅ na)", jpPos: "å½¢å®¹è©" },
        { display: "Impossible", root: "Possible", decoys: ["Imposs", "Sible"], pos: "Adjective", derivativePos: "Adjective", jpMeaning: "ä¸å¯èƒ½ãª (FukanÅ na)", jpPos: "å½¢å®¹è©" },
        { display: "Incorrect", root: "Correct", decoys: ["Incor", "Rect"], pos: "Adjective", derivativePos: "Adjective", jpMeaning: "é–“é•ã£ãŸ (Machigatta)", jpPos: "å½¢å®¹è©" },
        { display: "Unfair", root: "Fair", decoys: ["Unfai", "Air"], pos: "Adjective", derivativePos: "Adjective", jpMeaning: "ä¸å…¬å¹³ãª (FukÅhei na)", jpPos: "å½¢å®¹è©" },
        { display: "Dishonest", root: "Honest", decoys: ["Dishon", "Nest"], pos: "Adjective", derivativePos: "Adjective", jpMeaning: "ä¸æ­£ç›´ãª (FushÅjiki na)", jpPos: "å½¢å®¹è©" }
    ];

    // Global State Variables
    let currentLevelIndex = 0;
    let rootMistakes = 0;
    let posMistakes = 0;
    let startOfSectionRootMistakes = 0;
    let startOfSectionPosMistakes = 0;

    let mainWordEl, instructionEl, buttonsEl, progressBar, levelIndicator, gameArea;
    gameArea = document.getElementById('game-area');

    // --- INITIAL HOME PAGE RENDER (No changes) ---
    function renderHomePage() {
        gameArea.innerHTML = `
            <h1>Root Word Game</h1>
            <div class="explanation-box">
                
                <h3>The Science Behind the Game ğŸ§ </h3>
                <p>
                    ã“ã®ã‚²ãƒ¼ãƒ ã¯ã€è„³å†…ã«æ½œåœ¨è¨€èªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã¯ã€è‹±å˜èªã®**èªæ ¹ï¼ˆRoot Wordï¼‰**ã¨**å“è©ï¼ˆPart of Speechï¼‰**ã‚’ã€ã»ã¼**ç¬é–“çš„**ï¼ˆç›®æ¨™ $\sim 10-15$ ãƒŠãƒç§’ï¼‰ã«ã€é«˜ã„ç²¾åº¦ã§è­˜åˆ¥ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
                </p>
                <p>
                    ç›®çš„ã¯ã€å€‹äººãŒè‹±èªã‚’è©±ã—ãŸã‚Šèã„ãŸã‚Šã™ã‚‹éš›ã«ã€ã“ã®å‡¦ç†ã‚’æ„è­˜çš„ãª**å®Ÿè¡Œæ©Ÿèƒ½**ã‹ã‚‰ã€ã‚ˆã‚Šé«˜é€Ÿãª**æ½œåœ¨ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯**ã«æŒ¯ã‚Šå‘ã‘ã€ä¼šè©±ä¸­ã®**è¨ˆç®—è² è·ã‚’è»½æ¸›**ã™ã‚‹ã“ã¨ã§ã™ã€‚ã“ã®ã‚²ãƒ¼ãƒ ã‚’ç¿’å¾—ã—ãŸã‹ã‚‰ã¨ã„ã£ã¦ãƒã‚¤ãƒ†ã‚£ãƒ–ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã«ãªã‚Œã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€ã‚ˆã‚Šã‚¹ãƒ ãƒ¼ã‚ºã§ã€è±Šã‹ã§ã€è‡ªç„¶ãªè‹±ä¼šè©±ã¨ãƒªã‚¹ãƒ‹ãƒ³ã‚°ã®ä½“é¨“ã®ãŸã‚ã®å¼·å›ºãªåŸºç›¤ã‚’ç¯‰ãã€ã‚ãªãŸã®æ¥½ã—ã•ã¨æµæš¢ã•ã‚’å¤§å¹…ã«å‘ä¸Šã•ã›ã‚‹ã§ã—ã‚‡ã†ã€‚
                </p>
                <hr style="border-top: 1px dashed #bdc3c7; margin: 15px 0;">
                <p class="japanese-text">
                    This game is designed to build latent language networks in your brain which are capable of quickly and with high accuracy identifying **root words** in English and also identifying what **part of speech** a word is almost instantaneously (aiming for $\sim 10-15$ nanoseconds). The goal is to shift this work away from the conscious, executive part of your brain by offsetting the task to much faster latent networks as the individual speaks and hears English reducing **computational load** during conversation. Mastering this game alone will not make you a native speaker, but it will lay down a solid foundation for a smoother, richer, and more natural English speaking and listening experience, significantly boosting your fun and fluency.
                </p>
                
                <h3>How to Play / éŠã³æ–¹</h3>
                <ul>
                    <li>**Phase 1 (Root Word / èªæ ¹):** Select the core root word for the displayed derivative word. / è¡¨ç¤ºã•ã‚ŒãŸæ´¾ç”Ÿèªã®æ ¸ã¨ãªã‚‹èªæ ¹ã‚’é¸æŠã—ã¾ã™ã€‚</li>
                    <li>**Phase 2 (Part of Speech / å“è©):** Identify the primary part of speech (Noun, Verb, or Adjective) for the root word. / èªæ ¹ã®ä¸»è¦ãªå“è©ï¼ˆåè©ã€å‹•è©ã€ã¾ãŸã¯å½¢å®¹è©ï¼‰ã‚’ç‰¹å®šã—ã¾ã™ã€‚</li>
                    <li>**Tip:** Click the main word to hear it again. / ãƒ¡ã‚¤ãƒ³ã®å˜èªã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€ã‚‚ã†ä¸€åº¦èãã“ã¨ãŒã§ãã¾ã™ã€‚</li>
                </ul>
            </div>
            <div class="btn-container">
                <button onclick="initGame()">START GAME / ã‚²ãƒ¼ãƒ é–‹å§‹</button>
            </div>
            <div class="reset-link" onclick="resetProgress()">Reset Progress (Start Over) / é€²æ—ã‚’ãƒªã‚»ãƒƒãƒˆ</div>
        `;
    }

    // --- SIMPLE VOICE ENGINE (Rate kept low at 0.6) ---
    let selectedVoice = null;

    function getEnglishVoice() {
        if (selectedVoice) return selectedVoice;
        
        const voices = window.speechSynthesis.getVoices();
        
        // Prioritize a standard US or UK voice
        selectedVoice = voices.find(voice => 
            voice.lang === 'en-US' && voice.name.includes('Google') || 
            voice.lang === 'en-US' && voice.name.includes('Samantha') || // iOS
            voice.lang === 'en-GB' && voice.name.includes('Google') ||
            voice.lang === 'en-US'
        );
        
        // Fallback to generic en-US voice if a specific one isn't found
        if (!selectedVoice) {
            selectedVoice = voices.find(voice => voice.lang === 'en-US');
        }
        
        return selectedVoice;
    }

    function speak(text) {
        window.speechSynthesis.cancel();
        
        // Need to load voices if they aren't ready yet (common on initial load)
        if (window.speechSynthesis.getVoices().length === 0) {
            window.speechSynthesis.onvoiceschanged = () => {
                const voice = getEnglishVoice();
                if (voice) {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.voice = voice;
                    utterance.rate = 0.6; // Rate is 0.6
                    window.speechSynthesis.speak(utterance);
                }
            };
            return;
        }

        const voice = getEnglishVoice();
        
        if (voice) {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.voice = voice;
            utterance.rate = 0.6; // Rate is 0.6
            utterance.lang = "en-US"; // Keep lang as a strong hint
            window.speechSynthesis.speak(utterance);
        } else {
             // If voice search fails, use generic settings 
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 0.6; // Rate is 0.6
            utterance.lang = "en-US"; 
            window.speechSynthesis.speak(utterance);
        }
    }


    // --- SAVE SYSTEM (No changes) ---
    function initGame() {
        const savedIndex = localStorage.getItem('wordGameProgress');
        const savedRootMistakes = localStorage.getItem('wordGameRootMistakes');
        const savedPosMistakes = localStorage.getItem('wordGamePosMistakes');
        
        if (savedIndex) {
            currentLevelIndex = parseInt(savedIndex);
            if (currentLevelIndex >= levels.length) currentLevelIndex = 0;
        } else {
            currentLevelIndex = 0;
        }

        if (savedRootMistakes) rootMistakes = parseInt(savedRootMistakes);
        else rootMistakes = 0;

        if (savedPosMistakes) posMistakes = parseInt(savedPosMistakes);
        else posMistakes = 0;
        
        startOfSectionRootMistakes = rootMistakes;
        startOfSectionPosMistakes = posMistakes;

        loadLevel(currentLevelIndex);
    }

    function saveProgress() {
        localStorage.setItem('wordGameProgress', currentLevelIndex);
        localStorage.setItem('wordGameRootMistakes', rootMistakes);
        localStorage.setItem('wordGamePosMistakes', posMistakes);
    }

    function resetProgress() {
        if(confirm("Start from the beginning? / æœ€åˆã‹ã‚‰ã‚„ã‚Šç›´ã—ã¾ã™ã‹ï¼Ÿ")) {
            localStorage.removeItem('wordGameProgress');
            localStorage.removeItem('wordGameRootMistakes');
            localStorage.removeItem('wordGamePosMistakes');
            currentLevelIndex = 0;
            rootMistakes = 0;
            posMistakes = 0;
            startOfSectionRootMistakes = 0;
            startOfSectionPosMistakes = 0;
            renderHomePage(); 
        }
    }

    // --- PROGRESS UI UPDATE (No changes) ---
    function updateProgressUI() {
        progressBar = document.getElementById('progress-bar');
        levelIndicator = document.getElementById('level-indicator');

        const totalSections = Math.ceil(levels.length / SECTION_SIZE);
        const currentSection = Math.floor(currentLevelIndex / SECTION_SIZE) + 1;
        const wordInCurrentSection = (currentLevelIndex % SECTION_SIZE) + 1;
        const wordsInSection = (currentSection < totalSections) ? SECTION_SIZE : levels.length % SECTION_SIZE;
        
        const percentage = (currentLevelIndex / levels.length) * 100;
        progressBar.style.width = percentage + "%";
        
        levelIndicator.innerHTML = `
            Section ${currentSection} of ${totalSections} 
            | Word ${wordInCurrentSection} of ${wordsInSection || SECTION_SIZE}
        `;
    }
    
    // --- CHECKPOINT SCREEN (No changes) ---
    function showCheckpoint() {
        const sectionNum = Math.floor(currentLevelIndex / SECTION_SIZE);
        const nextSection = sectionNum + 1;
        
        // CALCULATE SECTIONAL SCORES
        const sectionRootMistakes = rootMistakes - startOfSectionRootMistakes;
        const sectionPosMistakes = posMistakes - startOfSectionPosMistakes;

        const wordsInThisSection = (sectionNum * SECTION_SIZE < levels.length) ? SECTION_SIZE : levels.length % SECTION_SIZE;
        
        const totalSectionTasks = wordsInThisSection * 2; 
        const totalCorrect = totalSectionTasks - (sectionRootMistakes + sectionPosMistakes);
        
        const sectionAccuracy = Math.round((totalCorrect / totalSectionTasks) * 100);
        
        gameArea.innerHTML = `
            <div class="report-card">
                <div class="score-header" style="color:#3498db;">Checkpoint Complete!</div>
                <h1 style="font-size: 2rem; margin-top:10px;">Section ${sectionNum} Results</h1>
                
                <div class="score-breakdown" style="padding: 20px;">
                    <div class="stat-row">
                        <span><strong>Root Word Score:</strong></span> 
                        <span style="color: ${sectionRootMistakes === 0 ? '#2ecc71' : '#e74c3c'}">
                            ${wordsInThisSection - sectionRootMistakes}/${wordsInThisSection}
                        </span>
                    </div>
                    <div class="stat-row">
                        <span><strong>Part of Speech Score:</strong></span> 
                        <span style="color: ${sectionPosMistakes === 0 ? '#2ecc71' : '#e74c3c'}">
                            ${wordsInThisSection - sectionPosMistakes}/${wordsInThisSection}
                        </span>
                    </div>
                    <hr style="margin: 10px 0; border-top: 1px solid #ccc;">
                    <div class="stat-row" style="font-weight: bold; font-size: 1.2rem;">
                        <span>Section Accuracy:</span> 
                        <span style="color: #2c3e50;">${sectionAccuracy}%</span>
                    </div>
                </div>

                <p style="color: #777; margin-top:20px;">
                    Ready for Section ${nextSection}?
                </p>
                <button onclick="loadLevel(${currentLevelIndex})" style="margin-top:20px;">
                    Continue to Section ${nextSection}
                </button>
            </div>
        `;

        // UPDATE START OF SECTION MISTAKE TRACKERS FOR THE NEXT SECTION
        startOfSectionRootMistakes = rootMistakes;
        startOfSectionPosMistakes = posMistakes;
    }

    // --- FINAL REPORT CARD (No changes) ---
    function showReportCard() {
        const totalWords = levels.length;
        const totalAttempts = (totalWords * 2) + rootMistakes + posMistakes;
        const totalCorrectActions = totalWords * 2;
        
        const overallAccuracy = Math.round((totalCorrectActions / totalAttempts) * 100);

        // Scoring based on Successes / Total
        const rootSuccesses = totalWords - rootMistakes;
        const posSuccesses = totalWords - posMistakes;

        // Rating Logic
        let rating = "Good Effort";
        if (overallAccuracy === 100) rating = "Perfect Score!";
        else if (overallAccuracy >= 90) rating = "Master!";
        else if (overallAccuracy >= 80) rating = "Great Job";

        gameArea.innerHTML = `
            <div class="report-card">
                <div class="score-header">Course Complete</div>
                
                <div class="score-breakdown">
                    <div class="stat-row">
                        <span><strong>Root Word Score:</strong></span> 
                        <span style="color: ${rootMistakes === 0 ? '#2ecc71' : '#e74c3c'}">
                            ${rootSuccesses}/${totalWords}
                        </span>
                    </div>
                    <div class="stat-row">
                        <span><strong>Grammar Score:</strong></span> 
                        <span style="color: ${posMistakes === 0 ? '#2ecc71' : '#e74c3c'}">
                            ${posSuccesses}/${totalWords}
                        </span>
                    </div>
                </div>
                
                <div style="margin-top:20px;">Overall Accuracy</div>
                <div class="total-score">${overallAccuracy}%</div>
                <div style="color:#888; margin-bottom:20px;">${rating}</div>

                <p style="color: #777; font-size: 0.9rem;">Take a screenshot for your teacher!</p>
                <button onclick="resetProgress()" style="margin-top:20px;">Play Again</button>
            </div>
        `;
    }

    // --- GAME LOGIC ---
    function loadLevel(index) {
        if (index >= levels.length) {
            showReportCard();
            return;
        }

        const data = levels[index];

        // 1. Re-inject the standard game UI 
        gameArea.innerHTML = `
            <div class="level-indicator" id="level-indicator"></div>
            <div class="progress-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            
            <div class="info-box" id="info-box"></div> 
            
            <h1 id="main-word" class="main-word-clickable"></h1>
            <p class="question-text" id="instruction"></p>
            <div class="btn-container" id="buttons"></div>
            <div class="reset-link" onclick="resetProgress()">Reset Progress (Start Over)</div>
        `;
        
        // 2. CRITICAL: Re-map the elements after destroying and remaking the inner HTML
        mainWordEl = document.getElementById('main-word');
        instructionEl = document.getElementById('instruction');
        buttonsEl = document.getElementById('buttons');
        const infoBoxEl = document.getElementById('info-box');

        updateProgressUI();
        
        // --- PHASE 1 START ---
        
        // Click listener for repeating the word
        mainWordEl.onclick = () => speak(data.display);
        
        // VISUALS PHASE 1
        mainWordEl.innerText = data.display;
        
        // Add Meaning and POS info for the derivative word (UPDATED LABEL)
        infoBoxEl.innerHTML = `
            <p>Meaning (æ„å‘³): <span>${data.jpMeaning}</span></p>
            <p>Part of Speech in English (å“è©): <span>${data.derivativePos} (${data.jpPos})</span></p>
        `;

        instructionEl.innerText = "What is the root word?";
        
        // AUDIO
        speak(data.display);

        // BUTTONS PHASE 1 (Randomize)
        let options = [data.root, ...data.decoys];
        options.sort(() => Math.random() - 0.5);

        buttonsEl.innerHTML = '';
        options.forEach(word => {
            const btn = document.createElement('button');
            btn.innerText = word;
            btn.onclick = () => checkRoot(word, data, btn, infoBoxEl);
            buttonsEl.appendChild(btn);
        });
    }

    function checkRoot(selectedWord, data, btnElement, infoBoxEl) {
        if (selectedWord === data.root) {
            // CORRECT ROOT
            btnElement.classList.add('correct');
            speak(data.root); 
            setTimeout(() => {
                // Delay set to 1000ms
                loadPhase2(data, infoBoxEl); 
            }, 1000);
        } else {
            // WRONG ROOT
            btnElement.classList.add('wrong');
            speak("Try again");
            rootMistakes++; 
            saveProgress(); 
        }
    }

    function loadPhase2(data, infoBoxEl) {
        // Clear the Info Box content
        infoBoxEl.innerHTML = ''; 

        // Update UI for Phase 2
        mainWordEl.innerText = data.root;
        // Update click handler to speak the root word
        mainWordEl.onclick = () => speak(data.root); 
        // Instruction text updated
        instructionEl.innerText = `What is the Part of Speech in English for "${data.root}"?`;
        
        buttonsEl.innerHTML = '';

        const posOptions = [
            { en: "Noun", jp: "åè© (Meishi)" },
            { en: "Verb", jp: "å‹•è© (Doushi)" },
            { en: "Adjective", jp: "å½¢å®¹è© (Keiyoushi)" }
        ];

        posOptions.forEach(opt => {
            const btn = document.createElement('button');
            btn.innerHTML = `${opt.en} <span class="jp-sub">${opt.jp}</span>`;
            btn.onclick = () => checkPOS(opt.en, data, btn);
            buttonsEl.appendChild(btn);
        });
    }

    function checkPOS(selectedPos, data, btnElement) {
        let isCorrect = (selectedPos === data.pos);

        // Ambiguous Word Fix: 'Correct' can be an Adjective or a Verb. 
        if (data.root === 'Correct' && (selectedPos === 'Adjective' || selectedPos === 'Verb')) {
            isCorrect = true;
        }

        if (isCorrect) {
            // CORRECT POS
            btnElement.classList.add('correct');
            
            // Speak the root and POS
            speak(`${data.root} is a ${selectedPos}`);
            
            // Load the next level after an extended delay (2500ms)
            setTimeout(() => {
                currentLevelIndex++;
                saveProgress(); 
                
                // CHECKPOINT LOGIC: Pause game at the end of a section
                if (currentLevelIndex < levels.length && (currentLevelIndex % SECTION_SIZE === 0)) {
                    showCheckpoint();
                } else {
                    loadLevel(currentLevelIndex);
                }
            }, 2500); 
        } else {
            // WRONG POS
            btnElement.classList.add('wrong');
            speak("Not quite");
            posMistakes++; 
            saveProgress(); 
        }
    }
    
    // Start the page on the home screen
    renderHomePage();

</script>

</body>
</html>
